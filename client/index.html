<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content" />
  <meta name="description" content="Portal de Login Meu Pre√ßo Certo" />
  <title>Meu Pre√ßo Certo</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Script para corrigir WebSocket HMR do Vite em ambiente Replit -->
  <script>
    // Interceptar cria√ß√£o de WebSocket para corrigir URLs inv√°lidas do Vite HMR
    (function() {
      const OriginalWebSocket = window.WebSocket;
      
      window.WebSocket = function(url, protocols) {
        // Se a URL cont√©m 'undefined' (problema do Vite HMR), corrigir
        if (typeof url === 'string' && url.includes('undefined')) {
          console.log('Corrigindo URL inv√°lida do Vite HMR:', url);
          
          // Detectar se estamos no Replit
          const isReplit = window.location.hostname.includes('replit.dev') || 
                          window.location.hostname.includes('replit.co') ||
                          window.location.hostname.includes('repl.co');
          
          if (isReplit) {
            // Para Replit, usar a URL base da p√°gina atual
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const correctedUrl = url.replace(/wss?:\/\/localhost:undefined/, `${protocol}//${window.location.host}`);
            console.log('URL corrigida para Replit:', correctedUrl);
            url = correctedUrl;
          } else {
            // Para desenvolvimento local, usar porta 3000
            url = url.replace(/localhost:undefined/, 'localhost:3000');
            console.log('URL corrigida para desenvolvimento local:', url);
          }
        }
        
        return new OriginalWebSocket(url, protocols);
      };
      
      // Preservar propriedades do WebSocket original
      Object.setPrototypeOf(window.WebSocket, OriginalWebSocket);
      window.WebSocket.prototype = OriginalWebSocket.prototype;
      for (let key in OriginalWebSocket) {
        if (OriginalWebSocket.hasOwnProperty(key)) {
          window.WebSocket[key] = OriginalWebSocket[key];
        }
      }
    })();
  </script>
  
  <!-- Script para evitar piscadas na tela de cadastro mobile - carregado condicionalmente -->
  <script>
    // Carregar o script apenas na p√°gina de cadastro mobile
    if (window.location.pathname === '/cadastre-se' || window.location.pathname === '/m/signup') {
      const script = document.createElement('script');
      script.src = '/src/pages/login/stop-flickering.js';
      document.head.appendChild(script);
    }
  </script>
  
  <style>
    /* Estilo b√°sico para o corpo */
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      overflow-x: hidden;
      background-color: white; /* Fundo branco para combinar com o splash screen */
    }
    
    /* Regras cr√≠ticas para prevenir que elementos desapare√ßam em modais */
    body[aria-hidden="true"],
    body[data-state="open"],
    body.dialog-open {
      position: static !important;
      overflow: auto !important;
      width: 100% !important;
      height: auto !important;
      visibility: visible !important;
      opacity: 1 !important;
      padding-right: 0 !important; /* Corrige o problema de padding lateral */
    }
    
    /* N√£o ocultar o root, apenas configurar a transi√ß√£o */
    #root {
      opacity: 1;
      transition: opacity 0.1s ease-in;
      visibility: visible !important;
    }
    
    /* Regra para preservar a visibilidade do menu e cabe√ßalho */
    body > div#root > div > header,
    body > div#root > div > nav,
    body > div#root > div > aside,
    body > div#root > div > main,
    body > div#root > div > div.sidebar {
      visibility: visible !important;
      opacity: 1 !important;
      display: flex !important;
    }
    
    /* Inicialmente ocultamos o menu em dispositivos m√≥veis */
    @media (max-width: 768px) {
      .sidebar {
        display: none !important;
      }
      
      /* Quando o menu for aberto, esta classe ser√° adicionada pelo React */
      .sidebar.sidebar-open {
        display: block !important;
      }
      
      /* Ajustes adicionais para telas pequenas */
      body {
        font-size: 14px;
      }
      
      table {
        display: block;
        overflow-x: auto;
        white-space: nowrap;
      }
    }
    
    /* Estilo para o splash screen - restaurado do original */
    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background-color: #f5f7fa;
      z-index: 9999;
      opacity: 1;
      transition: opacity 0.5s ease-out;
      padding: 20px;
      box-sizing: border-box;
      background-image: linear-gradient(to bottom, #f8fafc, #f1f5f9);
    }
    
    /* Container para os elementos de texto do splash */
    .splash-content {
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in;
    }
    
    /* Estilos para a anima√ß√£o de cursor */
    @keyframes blink-cursor {
      from, to { border-color: transparent; }
      50% { border-color: #0e4c92; }
    }
    
    #splash-screen.hidden {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease-out; /* Transi√ß√£o mais suave */
    }
    
    /* Pulsa√ß√£o para logo do splash */
    .splash-logo {
      width: 240px; /* Aumentado de 180px para 240px */
      margin-bottom: 2rem;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.05);
        opacity: 0.9;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    /* Anima√ß√£o para o cursor piscando */
    @keyframes blink-cursor {
      from, to { border-right-color: transparent }
      50% { border-right-color: #0e4c92 }
    }
    
    /* Texto do splash */
    .splash-text {
      color: #0e4c92;
      margin-top: 10px;
      font-size: 20px; /* Aumentado de 16px para 20px */
      font-weight: 600; /* Aumentado de 500 para 600 */
      text-align: center;
      min-height: 60px; /* Garantir espa√ßo para o texto sendo digitado mesmo com quebra de linha */
      display: block; /* Alterado para block para garantir centraliza√ß√£o consistente */
      width: 320px; /* Largura fixa para corresponder √† largura da barra de progresso */
      margin-left: auto;
      margin-right: auto;
      white-space: normal; /* Permite quebra de linha */
      word-wrap: break-word; /* Quebra palavras longas */
      word-break: keep-all; /* N√£o quebra palavras no meio */
      line-height: 1.5; /* Espa√ßamento entre linhas */
      position: relative; /* Para posicionamento absoluto do cursor */
    }
    
    /* Configura√ß√£o para quebra de linha na vers√£o mobile */
    @media (max-width: 768px) {
      .splash-text {
        white-space: pre-wrap; /* Preserva as quebras de linha \n */
      }
    }
    
    /* Estilo espec√≠fico para o efeito de digita√ß√£o */
    .typing-effect {
      display: inline-block;
      overflow: hidden;
      border-right: .15em solid #0e4c92; /* Cursor piscando */
      white-space: nowrap;
      margin: 0 auto;
      animation: typing 3.5s steps(40, end), blink-caret .75s step-end infinite;
    }
    
    /* Status do splash */
    .splash-status {
      margin-top: 8px;
      font-size: 14px;
      color: #64748b;
      min-height: 20px;
    }
    
    /* Barra de progresso */
    .splash-progress {
      width: 320px; /* Aumentado de 280px para 320px para corresponder ao logo maior */
      height: 6px; /* Aumentado de 4px para 6px para melhor visibilidade */
      background-color: #e2e8f0;
      border-radius: 3px; /* Ajustado para 3px */
      margin: 20px 0; /* Aumentado de 16px para 20px */
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Adicionado sombra suave */
    }
    
    .splash-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #0e4c92, #0080ff);
      border-radius: 3px; /* Ajustado para 3px */
      animation: loading 3s ease-in-out infinite; /* Tempo aumentado para 3s */
    }
    
    @keyframes loading {
      0% { width: 0%; }
      50% { width: 70%; }
      100% { width: 100%; }
    }
  </style>
</head>
<body>
  <!-- Splash screen original restaurado -->
  <div id="splash-screen">
    <img class="splash-logo" src="/images/webp/negativoo.webp" alt="Meu Pre√ßo Certo" onload="showSplashContent()" />
    <div class="splash-content">
      <div class="splash-text">Preparando tudo para voc√™...</div>
      <div class="splash-progress">
        <div class="splash-progress-bar"></div>
      </div>
      <div class="splash-status"></div>
    </div>
  </div>
  
  <div id="root"></div>
  
  <!-- Script para controlar a exibi√ß√£o do conte√∫do do splash -->
  <script>
    // Flag para controlar se a imagem j√° foi carregada
    window.splashImageLoaded = false;
    
    function showSplashContent() {
      // Marca a imagem como carregada
      window.splashImageLoaded = true;
      
      // Fun√ß√£o que ser√° chamada quando a imagem terminar de carregar
      const splashContent = document.querySelector('.splash-content');
      if (splashContent) {
        // Pequeno atraso para garantir que a transi√ß√£o seja suave
        setTimeout(() => {
          // Exibir diretamente o conte√∫do definindo os estilos
          splashContent.style.visibility = 'visible';
          splashContent.style.opacity = '1';
        }, 100);
      }
    }
    
    // Adicionar um safety fallback caso a imagem j√° esteja em cache
    // e o evento onload n√£o dispare normalmente
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        if (!window.splashImageLoaded) {
          console.log('Fallback: Imagem do splash parece j√° estar em cache, mostrando conte√∫do');
          showSplashContent();
        }
      }, 300);
    });
    
    // Fallback extra para garantir que o conte√∫do sempre apare√ßa
    window.addEventListener('load', function() {
      setTimeout(() => {
        const splashContent = document.querySelector('.splash-content');
        if (splashContent && (splashContent.style.opacity !== '1' || splashContent.style.visibility !== 'visible')) {
          console.log('Fallback final: Garantindo que o conte√∫do do splash seja exibido');
          splashContent.style.visibility = 'visible';
          splashContent.style.opacity = '1';
        }
      }, 500);
    });
  </script>
  
  <script type="module" src="/src/main.tsx"></script>
  
  <script>
    // Vari√°veis para controle do splash screen
    let splashRemoved = false;
    const pageLoadStartTime = performance.now();
    
    // Fun√ß√£o para remover o splash screen
    function hideSplash() {
      if (splashRemoved) return;
      
      // Verificar se estamos na landing page e se o conte√∫do da p√°gina j√° est√° carregado
      if (isLandingPage) {
        const rootContent = document.getElementById('root');
        const mainContent = rootContent ? rootContent.querySelector('main') : null;
        const headerContent = rootContent ? rootContent.querySelector('header') : null;
        const anySection = rootContent ? rootContent.querySelector('section') : null;
        const navContent = rootContent ? rootContent.querySelector('nav') : null;
        const landingLogo = rootContent ? rootContent.querySelector('img[src*="logo"]') : null;
        
        // Verificamos por qualquer elemento da p√°gina que indique que a landing page est√° carregada
        if (!headerContent && !anySection && !navContent && !landingLogo) {
          console.log("Conte√∫do principal da landing page ainda n√£o detectado, aguardando...");
          // Aguardar mais tempo para a primeira detec√ß√£o de conte√∫do
          setTimeout(hideSplash, 300); // Verificar novamente em 300ms
          return;
        } else {
          // Encontramos conte√∫do, mas vamos dar mais um tempo para que ele seja completamente carregado
          console.log("Conte√∫do da landing page detectado, aguardando renderiza√ß√£o completa...");
          setTimeout(() => {
            console.log("Renderiza√ß√£o completa, removendo splash");
            // Continuar com a remo√ß√£o do splash
            splashRemoved = true;
            const splash = document.getElementById('splash-screen');
            if (splash) {
              splash.classList.add('hidden');
              const removeTime = performance.now();
              console.log(`[‚è±Ô∏è Performance] Splash screen exibido por: ${(removeTime - pageLoadStartTime).toFixed(2)}ms`);
            }
          }, 500);
        }
      }
      
      const splash = document.getElementById('splash-screen');
      if (splash) {
        const removeTime = performance.now();
        console.log(`[‚è±Ô∏è Performance] Splash screen exibido por: ${(removeTime - pageLoadStartTime).toFixed(2)}ms`);
        
        // Adicionar classe para desaparecer com anima√ß√£o
        splash.classList.add('hidden');
        
        // Limpar flags de logout ap√≥s mostrar splash
        const params = new URLSearchParams(window.location.search);
        if (params.get('logout') === 'true' || 
            params.get('fromdirectlogout') === 'true' ||
            sessionStorage.getItem('isLogoutRedirect') === 'true') {
          
          console.log("Limpando flags de logout ap√≥s exibi√ß√£o do splash");
          // Limpar par√¢metros da URL
          if (params.has('logout') || params.has('fromdirectlogout')) {
            const cleanUrl = window.location.pathname;
            window.history.replaceState({}, document.title, cleanUrl);
          }
          
          // Limpar sessionStorage
          sessionStorage.removeItem('isLogoutRedirect');
          sessionStorage.removeItem('noSplashAfterLogout');
        }
        
        // Remover completamente ap√≥s a anima√ß√£o
        setTimeout(() => {
          splash.remove();
          const completeRemoveTime = performance.now();
          console.log(`[‚è±Ô∏è Performance] Splash screen completamente removido em: ${(completeRemoveTime - removeTime).toFixed(2)}ms`);
        }, 300);
        
        // Marcar como removido
        splashRemoved = true;
      }
    }
    
    // Exportar fun√ß√£o de remo√ß√£o para o escopo global
    window.hideSplashScreen = hideSplash;
    
    // Verificar se veio de logout ou est√° na landing page
    const params = new URLSearchParams(window.location.search);
    const pathname = window.location.pathname;
    const isLandingPage = pathname === '/' || pathname === '/home' || pathname === '/landing' || pathname.includes('/landing');
    const isLoginPage = pathname === '/acessar';
    const isSignupPage = pathname === '/cadastre-se';
    const isRecoverPage = pathname === '/recuperar';
    
    // Verificar se h√° 2FA pendente na sess√£o e redirecionar se necess√°rio
    const check2FAStatus = async () => {
      try {
        const response = await fetch('/api/auth/2fa/status');
        const data = await response.json();
        
        if (data && data.authenticated && data.twoFactorEnabled && !data.twoFactorVerified && data.requiresVerification) {
          console.log("üîí 2FA pendente detectado no carregamento da p√°gina. Redirecionando...");
          window.location.href = '/verificar-2fa';
          return true;
        }
      } catch (error) {
        console.log("Erro ao verificar status 2FA:", error);
      }
      return false;
    };
    
    // Verificar 2FA se estiver na p√°gina de login, cadastro ou recupera√ß√£o
    // e interromper o splash se for redirecionar
    if (isLoginPage || isSignupPage || isRecoverPage) {
      // Vamos suspender a exibi√ß√£o de textos no splash at√© confirmar se vai redirecionar
      const splashElement = document.getElementById('splash-screen');
      const splashText = document.querySelector('.splash-text');
      const originalText = splashText ? splashText.textContent : '';
      
      if (splashText) {
        splashText.textContent = 'Verificando autentica√ß√£o...';
      }
      
      // Verificamos 2FA antes de continuar
      (async () => {
        const needs2FA = await check2FAStatus();
        if (!needs2FA) {
          // Se n√£o precisar redirecionar, restaura o texto original
          if (splashText) {
            splashText.textContent = originalText;
          }
        } else {
          // Se vai redirecionar, remover o splash para evitar duplicidade
          if (splashElement) {
            splashElement.remove();
          }
        }
      })();
    }
    
    let isLogout = params.get('logout') === 'true' || 
                  params.get('fromdirectlogout') === 'true' ||
                  sessionStorage.getItem('isLogoutRedirect') === 'true' ||
                  sessionStorage.getItem('noSplashAfterLogout') === 'true';
                  
    // Gerenciar o estado da sess√£o para a landing page
    if (isLandingPage) {
      // Limpar qualquer estado de sess√£o anterior para garantir que 
      // o splash da landing page seja mostrado corretamente
      sessionStorage.removeItem('landingPageSplashShown');
      sessionStorage.removeItem('landingPageShowingSplash');
      
      // Vamos sempre mostrar o splash na landing page,
      // ignorando se j√° foi mostrado anteriormente
      console.log("Landing page detectada - sempre mostrando o splash");
    }
    
    // Verifica√ß√£o adicional para depura√ß√£o
    console.log("Verificando p√°gina e flags:", {
      isLandingPage: isLandingPage,
      pathname: pathname,
      urlLogout: params.get('logout') === 'true',
      urlFromDirectLogout: params.get('fromdirectlogout') === 'true',
      sessionIsLogoutRedirect: sessionStorage.getItem('isLogoutRedirect') === 'true',
      sessionNoSplashAfterLogout: sessionStorage.getItem('noSplashAfterLogout') === 'true'
    });
    
    // Atualizar texto principal do splash
    const splashText = document.querySelector('.splash-text');
    if (splashText) {
      // Verificar se estamos na p√°gina de verifica√ß√£o 2FA OU se h√° uma verifica√ß√£o 2FA pendente
      const is2FAVerifyPage = pathname === '/verificar-2fa';
      const has2FAPending = localStorage.getItem('pendingTwoFactor') === 'true';
      
      // Se estamos na p√°gina de verifica√ß√£o 2FA ou temos 2FA pendente durante login/cadastro
      if (is2FAVerifyPage || has2FAPending) {
        // Array de mensagens alternativas para 2FA
        const mensagens2FA = [
          'Verifica√ß√£o de seguran√ßa necess√°ria...',
          'Protegendo sua conta com autentica√ß√£o adicional...',
          'Aguardando c√≥digo de verifica√ß√£o...',
          'Sistema de prote√ß√£o avan√ßada ativado...',
          'Verifica√ß√£o de identidade em andamento...',
          'Seguran√ßa em dobro para sua tranquilidade...',
          'Confirmando que √© realmente voc√™...'
        ];
        
        // √çndice inicial aleat√≥rio
        let mensagemIndex = Math.floor(Math.random() * mensagens2FA.length);
        
        // Fun√ß√£o para alternar mensagens com efeito de fade
        const alternarMensagens = () => {
          // Aplicar efeito de fade out
          splashText.style.opacity = '0';
          
          setTimeout(() => {
            // Mudar para pr√≥xima mensagem
            mensagemIndex = (mensagemIndex + 1) % mensagens2FA.length;
            splashText.textContent = mensagens2FA[mensagemIndex];
            
            // Aplicar efeito de fade in
            splashText.style.opacity = '1';
          }, 500); // 500ms para o fade out
        };
        
        // Definir mensagem inicial
        splashText.textContent = mensagens2FA[mensagemIndex];
        splashText.style.transition = 'opacity 0.5s ease';
        
        // Alternar mensagens a cada 4 segundos
        const intervaloMensagens = setInterval(alternarMensagens, 4000);
        
        // Limpar intervalo quando o splash for removido
        window.addEventListener('beforeunload', () => clearInterval(intervaloMensagens));
        
        console.log("Detectada necessidade de verifica√ß√£o 2FA - alterando texto do splash com anima√ß√£o");
      } else if (isLogout) {
        splashText.textContent = 'Finalizando sua sess√£o...';
        console.log("Detectado logout - alterando texto do splash");
      } else if (isLoginPage) {
        // Verificar se foi um redirecionamento expl√≠cito da landing
        let redirecionado = false;
        try {
          redirecionado = localStorage.getItem('splashRedirectType') === 'login';
          if (redirecionado) {
            console.log("Detectado redirecionamento espec√≠fico para login");
            localStorage.removeItem('splashRedirectType');
          }
        } catch (e) {
          console.error("Erro ao verificar redirecionamento de login:", e);
        }
        
        // Array de mensagens para tela de login
        const mensagensLogin = [
          'Estou te transferindo para tela de login...',
          'Preparando ambiente de acesso seguro...',
          'Configurando formul√°rio de acesso...',
          'Carregando √°rea de login...',
          'Aguarde enquanto preparamos tudo...'
        ];
        
        // √çndice inicial aleat√≥rio
        let mensagemIndex = Math.floor(Math.random() * mensagensLogin.length);
        splashText.textContent = mensagensLogin[mensagemIndex];
        splashText.style.transition = 'opacity 0.5s ease';
        
        console.log("Detectada p√°gina de login - mostrando mensagens prolongadas");
        
        // N√£o alternar mensagens t√£o rapidamente para login - s√≥ a cada 5 segundos
        const intervaloLogin = setInterval(() => {
          splashText.style.opacity = '0';
          
          setTimeout(() => {
            mensagemIndex = (mensagemIndex + 1) % mensagensLogin.length;
            splashText.textContent = mensagensLogin[mensagemIndex];
            splashText.style.opacity = '1';
          }, 500);
        }, 5000);
        
        // Limpar intervalo quando o splash for removido
        window.addEventListener('beforeunload', () => clearInterval(intervaloLogin));
        
      } else if (isSignupPage) {
        // Verificar se foi um redirecionamento expl√≠cito da landing
        let redirecionado = false;
        try {
          redirecionado = localStorage.getItem('splashRedirectType') === 'cadastro';
          if (redirecionado) {
            console.log("Detectado redirecionamento espec√≠fico para cadastro");
            localStorage.removeItem('splashRedirectType');
          }
        } catch (e) {
          console.error("Erro ao verificar redirecionamento de cadastro:", e);
        }
        
        // Array de mensagens para tela de cadastro
        const mensagensCadastro = [
          'Estou te transferindo para tela de cadastro...',
          'Preparando formul√°rio de registro...',
          'Configurando ambiente para novo cadastro...',
          'Carregando assistente de cadastro...',
          'Preparando para sua nova conta...',
          'Criando sua experi√™ncia de cadastro...',
          'Preparando ambiente seguro para cadastro...'
        ];
        
        // √çndice inicial aleat√≥rio
        let mensagemIndex = Math.floor(Math.random() * mensagensCadastro.length);
        splashText.textContent = mensagensCadastro[mensagemIndex];
        splashText.style.transition = 'opacity 0.5s ease';
        
        console.log("Detectada p√°gina de cadastro - mostrando mensagens prolongadas");
        
        // N√£o alternar mensagens t√£o rapidamente para cadastro - s√≥ a cada 5 segundos
        const intervaloCadastro = setInterval(() => {
          splashText.style.opacity = '0';
          
          setTimeout(() => {
            mensagemIndex = (mensagemIndex + 1) % mensagensCadastro.length;
            splashText.textContent = mensagensCadastro[mensagemIndex];
            splashText.style.opacity = '1';
          }, 500);
        }, 5000);
        
        // Limpar intervalo quando o splash for removido
        window.addEventListener('beforeunload', () => clearInterval(intervaloCadastro));
        
      } else if (isRecoverPage) {
        // Verificar se foi um redirecionamento expl√≠cito
        let redirecionado = false;
        try {
          redirecionado = localStorage.getItem('splashRedirectType') === 'recuperar';
          if (redirecionado) {
            console.log("Detectado redirecionamento espec√≠fico para recupera√ß√£o");
            localStorage.removeItem('splashRedirectType');
          }
        } catch (e) {
          console.error("Erro ao verificar redirecionamento de recupera√ß√£o:", e);
        }
        
        // Array de mensagens para recupera√ß√£o
        const mensagensRecuperar = [
          'Estou te transferindo para tela de recupera√ß√£o...',
          'Preparando sistema de recupera√ß√£o de conta...',
          'Configurando ferramentas de seguran√ßa...',
          'Carregando assistente de recupera√ß√£o...',
          'Inicializando processo de recupera√ß√£o...',
          'Configurando ambiente seguro para recupera√ß√£o...',
          'Preparando sistema para restaurar seu acesso...',
          'Montando assistente de recupera√ß√£o de senha...'
        ];
        
        // √çndice inicial aleat√≥rio
        let mensagemIndex = Math.floor(Math.random() * mensagensRecuperar.length);
        splashText.textContent = mensagensRecuperar[mensagemIndex];
        splashText.style.transition = 'opacity 0.5s ease';
        
        console.log("Detectada p√°gina de recupera√ß√£o - mostrando mensagens prolongadas");
        
        // N√£o alternar mensagens t√£o rapidamente para recupera√ß√£o - s√≥ a cada 5 segundos
        const intervaloRecuperar = setInterval(() => {
          splashText.style.opacity = '0';
          
          setTimeout(() => {
            mensagemIndex = (mensagemIndex + 1) % mensagensRecuperar.length;
            splashText.textContent = mensagensRecuperar[mensagemIndex];
            splashText.style.opacity = '1';
          }, 500);
        }, 5000);
        
        // Limpar intervalo quando o splash for removido
        window.addEventListener('beforeunload', () => clearInterval(intervaloRecuperar));
      } else if (isLandingPage) {
        // Para landing page, vamos adicionar um efeito de digita√ß√£o
        const textToType = 'O melhor pre√ßo come√ßa\ncom o pre√ßo certo';
        splashText.textContent = ''; // Come√ßar com texto vazio
        
        // Fun√ß√£o para simular efeito de digita√ß√£o
        // Abordagem melhorada para o efeito de digita√ß√£o
        function typeEffect(text, element, i = 0) {
          if (i < text.length) {
            // Atualiza o texto
            element.textContent = text.substring(0, i+1);
            
            // Configura o container para permitir quebra de linha nos pontos espec√≠ficos definidos pelo \n
            // Configura o container para permitir apenas uma quebra de linha
            element.style.display = 'block';
            element.style.width = '250px'; // Largura fixa para controlar quebra
            element.style.width = '280px'; // Largura fixa para garantir apenas uma quebra
            element.style.margin = '0 auto';
            element.style.whiteSpace = 'pre-wrap'; // Preserva quebras de linha \n
            element.style.overflowWrap = 'normal'; // Evita quebras de palavras
            element.style.overflow = 'hidden'; // Previne expans√£o desnecess√°ria
            element.style.textAlign = 'center';
            element.style.lineHeight = '1.3'; // Diminui espa√ßamento entre linhas
            
            // Um pseudo-elemento para o cursor que funciona em todas as linhas
            const cursor = document.createElement('span');
            cursor.style.display = 'inline-block';
            cursor.style.width = '2px';
            cursor.style.height = '1em'; // Altura menor para n√£o ultrapassar a linha
            cursor.style.backgroundColor = '#0e4c92';
            cursor.style.verticalAlign = 'middle';
            cursor.style.marginLeft = '2px';
            cursor.style.position = 'relative'; // Posicionamento relativo
            cursor.style.top = '0px'; // Alinhamento com o texto
            cursor.style.animation = 'blink-cursor 0.7s step-end infinite';
            cursor.id = 'typing-cursor';
            
            // Adiciona o cursor ap√≥s o texto atual
            element.appendChild(cursor);
            
            // Continua a digita√ß√£o
            setTimeout(() => typeEffect(text, element, i + 1), 45);
          } else {
            // Quando terminar de digitar, remove o cursor imediatamente e adiciona o ponto
            // Remove o cursor imediatamente
            const cursor = document.getElementById('typing-cursor');
            if (cursor) {
              cursor.remove();
            }
            
            // Adiciona o ponto de exclama√ß√£o no texto
            element.textContent = element.textContent + '!';
            element.style.textAlign = 'center';
            
            console.log("Digita√ß√£o completa, cursor removido");
          }
        }
        
        // Iniciar o efeito de digita√ß√£o ap√≥s um pequeno delay
        setTimeout(() => {
          typeEffect(textToType, splashText);
        }, 300);
        
        console.log("Detectada landing page - iniciando efeito de digita√ß√£o no texto");
      }
    }
                    
    // Definir mensagens com base no contexto
    const loadingMessages = isLogout ? [
      "Encerrando sess√£o...",
      "Limpando dados tempor√°rios...",
      "Finalizando conex√µes...",
      "Sess√£o encerrada com sucesso!"
    ] : isLoginPage ? [
      "Preparando √°rea de acesso...",
      "Carregando formul√°rio de login...",
      "Configurando autentica√ß√£o...",
      "Quase pronto para o acesso..."
    ] : isSignupPage ? [
      "Preparando formul√°rio de cadastro...",
      "Configurando valida√ß√µes...",
      "Estabelecendo conex√£o segura...",
      "Quase pronto para o cadastro..."
    ] : isRecoverPage ? [
      "Preparando sistema de recupera√ß√£o...",
      "Configurando valida√ß√µes de seguran√ßa...",
      "Preparando envio de instru√ß√µes...",
      "Quase pronto para recuperar sua senha..."
    ] : isLandingPage ? [
      // Para a landing page, n√£o mostramos mensagens rotativas
      ""
    ] : [
      "Conectando ao banco de dados...",
      "Carregando interface...",
      "Preparando componentes...",
      "Configurando recursos...",
      "Carregando m√≥dulos...",
      "Quase pronto...",
      "Iniciando aplica√ß√£o..."
    ];

    // Exibir a primeira mensagem imediatamente (ou deixar vazio para landing page)
    const statusElement = document.querySelector('.splash-status');
    const progressElement = document.querySelector('.splash-progress');
    
    if (statusElement) {
      statusElement.textContent = loadingMessages[0];
      // Esconder completamente o elemento de status na landing page
      if (isLandingPage) {
        statusElement.style.display = 'none';
        // Tamb√©m esconder a barra de progresso na landing page
        if (progressElement) {
          progressElement.style.display = 'none';
        }
      }
    }

    // Se for logout, atualizar as mensagens mais rapidamente
    const messageInterval = isLogout ? 800 : 700;
    
    // Fun√ß√£o para atualizar a mensagem de status
    let messageIndex = 0;
    function updateStatusMessage() {
      const statusElement = document.querySelector('.splash-status');
      if (statusElement && messageIndex < loadingMessages.length && !isLandingPage) {
        statusElement.textContent = loadingMessages[messageIndex];
        messageIndex++;
        
        if (messageIndex >= loadingMessages.length) {
          messageIndex = 0; // Volta ao in√≠cio se necess√°rio
        }
      }
    }
    
    // Iniciar a exibi√ß√£o das mensagens (exceto na landing page)
    if (!isLandingPage) {
      updateStatusMessage();
      var messageTimer = setInterval(updateStatusMessage, 800);
    } else {
      console.log("N√£o exibindo mensagens rotativas na landing page");
      var messageTimer = null; // Nenhum timer para landing page
    }
    
    // Fun√ß√£o para verificar se o conte√∫do da p√°gina j√° est√° pronto
    function checkContent() {
      const root = document.getElementById('root');
      if (root) {
        // Verificar se o header j√° est√° carregado (um bom indicador de conte√∫do)
        const header = root.querySelector('header');
        if (header) {
          const headerTime = performance.now();
          console.log(`[‚è±Ô∏è Performance] Header detectado em: ${(headerTime - pageLoadStartTime).toFixed(2)}ms`);
          console.log(`[‚è±Ô∏è Performance] Tornando o conte√∫do principal vis√≠vel`);
          console.log(`[‚è±Ô∏è Performance] Header encontrado, removendo splash definitivamente`);
          // Parar a rota√ß√£o de mensagens
          clearInterval(messageInterval);
          hideSplash();
          return true;
        }
        
        // Verificar se temos a primeira se√ß√£o carregada
        const mainSection = root.querySelector('main section:first-child');
        if (mainSection) {
          const contentTime = performance.now();
          console.log(`[‚è±Ô∏è Performance] Conte√∫do detectado ap√≥s: ${(contentTime - pageLoadStartTime).toFixed(2)}ms`);
          console.log(`[‚è±Ô∏è Performance] Elementos chave carregados: header primeira se√ß√£o`);
          console.log(`[‚è±Ô∏è Performance] Conte√∫do vis√≠vel, iniciando remo√ß√£o do splash`);
          // Parar a rota√ß√£o de mensagens
          clearInterval(messageInterval);
          hideSplash();
          
          return true;
        }
        
        // Verifica√ß√£o alternativa baseada em elementos vis√≠veis
        const visibleElements = root.querySelectorAll('div:not([style*="display:none"]):not([style*="display: none"]):not([style*="visibility:hidden"]):not([style*="visibility: hidden"])');
        
        if (visibleElements.length > 1) {
          const contentTime = performance.now();
          console.log(`[‚è±Ô∏è Performance] Elementos vis√≠veis detectados ap√≥s: ${(contentTime - pageLoadStartTime).toFixed(2)}ms`);
          console.log(`[‚è±Ô∏è Performance] Total de elementos vis√≠veis: ${visibleElements.length}`);
          
          // Removemos o splash imediatamente
          console.log("[‚è±Ô∏è Performance] Conte√∫do vis√≠vel, iniciando remo√ß√£o do splash");
          // Parar a rota√ß√£o de mensagens
          clearInterval(messageInterval);
          hideSplash();
          
          return true;
        }
      }
      return false;
    }
    
    // Verificar se estamos em processo de logout
    // Evitamos verificar window.LOGOUT_IN_PROGRESS diretamente para evitar erros
    
    // Ajustar tempos baseado no tipo de opera√ß√£o
    const checkInterval = isLogout ? 100 : isLandingPage ? 50 : 25; // Mais lento para logout, m√©dio para landing
    // Definir tempos de timeout personalizados por tipo de p√°gina
    let timeoutDuration = 10000; // Padr√£o (10 segundos)
    
    // Verificar se estamos na p√°gina de verifica√ß√£o 2FA
    const is2FAVerifyPage = pathname === '/verificar-2fa';
    
    // Removemos esta verifica√ß√£o global para evitar problemas
    // A verifica√ß√£o espec√≠fica ser√° feita dentro de cada se√ß√£o para maior seguran√ßa
    
    if (isLogout) {
      timeoutDuration = 3000; // Logout (3 segundos)
    } else if (isLandingPage) {
      timeoutDuration = 5000; // Landing page (5 segundos)
    } else if (isLoginPage) {
      timeoutDuration = 18000; // Login (18 segundos - bem mais tempo)
    } else if (isSignupPage) {
      timeoutDuration = 18000; // Cadastro (18 segundos - bem mais tempo)
    } else if (isRecoverPage) {
      timeoutDuration = 15000; // Recupera√ß√£o (15 segundos)
    } else if (is2FAVerifyPage) {
      timeoutDuration = 15000; // Verifica√ß√£o 2FA (15 segundos)
    }
    
    console.log(`Configurando verifica√ß√£o de conte√∫do a cada ${checkInterval}ms e timeout de ${timeoutDuration}ms`);
    console.log(`Status de logout: ${isLogout ? 'Sim' : 'N√£o'}, Landing page: ${isLandingPage ? 'Sim' : 'N√£o'}`);
    
    // Tempos m√≠nimos espec√≠ficos para cada contexto
    if (isLogout) {
      console.log("Detectado processo de logout - exibindo splash por tempo m√≠nimo de 1.5s");
      setTimeout(() => {
        console.log("Tempo m√≠nimo para exibi√ß√£o do splash de logout atingido");
      }, 1500);
    } else if (isLandingPage) {
      console.log("Detectada landing page - exibindo splash por tempo fixo de 5s");
      
      // Para landing page vamos verificar se o conte√∫do j√° est√° carregado
      let landingPageContentCheckerInterval = setInterval(() => {
        const root = document.getElementById('root');
        
        // Verificamos se a landing page j√° est√° carregada verificando se existem elementos vis√≠veis
        if (root && root.children.length > 0) {
          // Verificamos qualquer elemento principal da p√°gina
          const anyContent = document.querySelector('.landing-hero') || 
                            document.querySelector('main') || 
                            document.querySelector('section') || 
                            document.querySelector('header') ||
                            document.querySelector('nav');
          
          // Se qualquer um desses elementos estiver presente, podemos considerar que a p√°gina est√° carregando
          if (anyContent) {
            console.log("Conte√∫do da landing page detectado, preparando para remover splash");
            
            console.log("Elemento encontrado:", anyContent.tagName || anyContent.className);
            
            // Aguardamos um tempo maior para garantir que o restante da p√°gina seja carregado
            // Isso evita a tela em branco entre o splash e o conte√∫do
            setTimeout(() => {
              console.log("Removendo splash da landing page ap√≥s carregamento do conte√∫do");
              // Neste ponto, a p√°gina deve estar visualmente pronta para ser mostrada
              hideSplash();
              clearInterval(landingPageContentCheckerInterval);
            }, 800);
          }
        }
      }, 200); // Verificar a cada 200ms
      
      // Timeout de seguran√ßa para a landing page - caso o conte√∫do demore muito
      setTimeout(() => {
        if (landingPageContentCheckerInterval) {
          clearInterval(landingPageContentCheckerInterval);
          console.log("Timeout da landing page atingido, removendo splash");
          hideSplash();
        }
      }, 8000); // M√°ximo de 8 segundos
      
      // Desativamos a verifica√ß√£o do conte√∫do para a landing page
      // para garantir que o splash seja exibido pelo tempo completo
      sessionStorage.setItem('landingPageShowingSplash', 'true');
    }
    
    // Verificar periodicamente se o conte√∫do existe
    const contentCheckInterval = setInterval(function() {
      // Para logout: n√£o remover o splash automaticamente pelo conte√∫do
      // Para landing page: NUNCA removemos por detec√ß√£o de conte√∫do
      
      // Verificar conte√∫do apenas se n√£o for logout e n√£o for landing page
      if (!isLogout && !isLandingPage && checkContent()) {
        // Para p√°ginas normais (n√£o landing page, n√£o logout)
        // podemos remover o splash quando o conte√∫do estiver pronto
        console.log("Conte√∫do detectado, removendo splash screen");
        clearInterval(contentCheckInterval);
        hideSplash();
      }
    }, checkInterval);
    
    // Timeout de seguran√ßa para remover o splash ap√≥s um tempo m√°ximo
    // Para a landing page, n√£o usamos o timeout de seguran√ßa pois queremos
    // controlar o tempo de exibi√ß√£o com precis√£o
    if (!isLandingPage) {
      setTimeout(function() {
        const timeoutTime = performance.now();
        console.log(`[‚è±Ô∏è Performance] Timeout de seguran√ßa atingido ap√≥s: ${(timeoutTime - pageLoadStartTime).toFixed(2)}ms`);
        console.log(`Timeout de seguran√ßa atingido, removendo splash`);
        // Parar o intervalo de mensagens ao atingir o timeout
        if (typeof messageInterval !== 'undefined') {
          clearInterval(messageInterval);
        }
        hideSplash();
      }, timeoutDuration);
    } else {
      console.log("Landing page - n√£o usando timeout de seguran√ßa");
    }
  </script>
</body>
</html>